// This Test Port skeleton source file was generated by the
// TTCN-3 Compiler of the TTCN-3 Test Executor version CRL 113 200/6 R5B
// for ebotbar (ebotbar@ebotbarVB) on Mon Apr 29 13:25:58 2019

// Copyright (c) 2000-2021 Ericsson Telecom AB

// You may modify this file. Complete the body of empty functions and
// add your member functions here.

#include "PT.hh"

namespace map__param__common {

PT::PT(const char *par_port_name)
	: PT_BASE(par_port_name)
{

}

PT::~PT()
{

}

void PT::set_parameter(const char * /*parameter_name*/,
	const char * /*parameter_value*/)
{

}

/*void PT::Handle_Fd_Event(int fd, boolean is_readable,
	boolean is_writable, boolean is_error) {}*/

void PT::Handle_Fd_Event_Error(int /*fd*/)
{

}

void PT::Handle_Fd_Event_Writable(int /*fd*/)
{

}

void PT::Handle_Fd_Event_Readable(int /*fd*/)
{

}

/*void PT::Handle_Timeout(double time_since_last_call) {}*/

void PT::user_map(const char * /*system_port*/, Map_Params& params)
{
  if (params.get_nof_params() != 0) {
    CHARSTRING p1_str = params.get_param(0);
    if (p1_str.lengthof() > 0) {
      // OK
      OCTETSTRING p1;
      string_to_ttcn(params.get_param(0), p1);
      // check the value
      if (p1 != P1__INITIAL) {
        char* reason = mprintf("Initial value of parameter p1 is incorrect: %s", (const char*) p1_str);
        TTCN_Runtime::setverdict(FAIL, reason);
        Free(reason);
      }
    }
    else {
      // not OK
      TTCN_Runtime::setverdict(FAIL, "Parameter p1 is unset");
    }
    
    CHARSTRING p2_str = params.get_param(1);
    if (p2_str.lengthof() == 0) {
      // OK
      // now set the output value
      params.set_param(1, ttcn_to_string(P2__FINAL));
    }
    else {
      // not OK
      char* reason = mprintf("Parameter p2 is set: %s", (const char*) p2_str);
      TTCN_Runtime::setverdict(FAIL, reason);
      Free(reason);
    }
    CT_component_map__param = TRUE;
  }
  else {
    CT_component_map__empty = TRUE;
  }
}

void PT::user_unmap(const char * /*system_port*/, Map_Params& params)
{
  if (params.get_nof_params() != 0) {
    CHARSTRING p_str = params.get_param(0);
    if (p_str.lengthof() > 0) {
      // OK
      INTEGER p;
      string_to_ttcn(params.get_param(0), p);
      // check the input value
      if (p != P__INITIAL) {
        char* reason = mprintf("Initial value of parameter p is incorrect: %s", (const char*) p_str);
        TTCN_Runtime::setverdict(FAIL, reason);
        Free(reason);
      }
      else {
        // set the output value
        params.set_param(0, ttcn_to_string(P__FINAL));
      }
    }
    else {
      // not OK
      TTCN_Runtime::setverdict(FAIL, "Parameter p is unset");
    }
    CT_component_unmap__param = TRUE;
  }
  else {
    CT_component_unmap__empty = TRUE;
  }
}

void PT::user_start()
{

}

void PT::user_stop()
{

}

void PT::outgoing_send(const CHARSTRING& /*send_par*/)
{

}

} /* end of namespace */

